#pragma region 객체지향 프로그래밍(OOP)
/*
=> 객체 지향 프로그래밍(OOP)
- 코드의 재사용성이 높고 코드의 관리가 용이하다.
- 기준점이 있기 때문에 신뢰성이 높은 프로그래밍을 가능하게 한다.


=> 객체지향 4대 특징
캡슐화 / 상속 / 다형성 / 추상화

1. 캡슐화
- 객체의 속성을 보호하기 위한 키워드 (객체 훼손 방지)

2. 상속
- 객체지향에서의 상속은 하위로 내려 갈수록 구체화 되는 것을 의미한다.
- 재사용성 향상 + 확장성 향상 + 유지보수성 향상 + 프로그램 구조에 대한 이해도를 높일 수 있다.

3. 다형성
- 하나의 객체가 여러 형태로 변화하는것을 의미한다.
  ㄴ 오버라이딩

4. 추상화
- 공통적인 부분과 특성을 분리 및 추출하여 재조합 및 재구성하는것을 의미한다.

=> 객체지향 5대 설계 원칙 SOLID

1. SRP (단일 책임의 원칙)
ㄴ 결합도는 낮추고 응집도를 높여라
ㄴ 상속 / 오버라이딩을 사용하면 응집도가 높아진다.


2. OCP (개방 폐쇄의 원칙)
ㄴ 자신의 확장에는 열려 있고 / 주변의 변화에 대해서는 닫혀 있어야 한다.


3. LSP (리스코브 치환의 원칙)
ㄴ 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체가 가능해야 한다. (제네시스는 => 자동차)


4. ISP (인터페이스 분리 원칙)
ㄴ 클라이언트는 자신이 사용하지 않는 함수 / 메서드에 의존 관계를 맺으면 안된다.
ㄴ 각자할것만


5. DIP (의존관계 역전의 원칙)
ㄴ 자신보다 변하기 쉬운것에 의존하면 안된다.


*/
#pragma endregion
#pragma region 순수가상함수
/*
=> 순수 가상함수 ( 1개라도 있으면 추상 클래스라고 한다.)
- 함수의 구현부가 없고, 기본적으로 선언부가 = 0으로 끝나는 가상함수를 뜻한다.
- 부모 클래스에서 순수 가상함수를 선언하면 자식 클래스에서 반드시 재정의한
  함수를 멤버로 가져와야 한다.

  순수가상 함수 사용 예시
virtual void IFunction() PURE; ( = 0 , abstract , = NULL)

메인 프로시져
LRESULT : 콜백의 반환형으로 많이 사용이 된다.
ㄴ 메세지 처리를 마친후에 OS에게 신호를 주기 위한 값
ㄴ 스위치문에서 각 메세지에 대한 처리값을 -1, 0, 1로 운영체제에 어떤
작업을 해야하는지 알려주는 역할을 한다. 기본적으로 0이 리턴되면 모든 메세지가 처리되었다는 것을 의미한다.

자식 객체의 소멸자를 호출하기 위해 사용
virtual ~GameNode() {};

EX)
- 선언 예시    명시
IFunction() = 0;
IFunction() = NULL;
IFunction() PURE;
IFunction() abstract;

=> 추상 클래스
- 순수 가상 함수가 N개 이상 있는 클래스를 의미한다.

-> 특징
1. 객체를 생성할 수 없다.
2. 포인터 변수는 만들 수 있다. (미리 만들어 넣고 그 메모리에 데이터를 넣는다.)
3. 추상 클래스로 지정한 객체는 인스턴스를 만들 수 없다.
ㄴ 클래스

4. 추상 클래스의 자식 클래스를 통해 인스턴스를 생성할 수 없다.
5. c++언어가 개정되면서 추가된 abstract 키워드를 통해 명시하는것 가능
6. 더 나아가 C++11 이상의 버전부터는 멤버 변수 또는 멤버 함수가 포함된 여부와
   상관 없이 순수 가상함수를 1개 이상 가지고 있다면 이 클래스는 추상 클래스로 승격이 된다.

C++
IWindowMessageHandler abstract
{

};
C# (언리얼에서도 사용)
abstract class ITessellation
{

};

=> 인터페이스
- OCP ( 개방 폐쇠)
ㄴ 자신의 확장에는 열려 있고, 주변 변화에 대해서는 닫혀 있어야 한다.
- 순수 가상함수로만 이루어진 클래스를 인터페이스라고 불렀다
ㄴ 지금도 인터페이스로 부른다.
- 인터페이스의 개념은 하위 클래스에서 반드시 정의해야 할 함수를 정해주는 클래스라고 할 수 있다.
- C//C++ 언어에서는 공식적으로 인터페이스라는 기능을 지원하지 않는다.

표기법 : 파스칼케이스
구조도(C++기준)

interface -> (상속) -> abstract 클래스 (기본 기능 구현) ->
(상속) -> 기본 클래스 (순수 가상함수 재정의)

=> 인터페이스 특징
- 멤버 변수 및 함수를 포함할 수 없다.(정적 함수 포함)
- 속성을 정의하는 한정자 사용금지
ㄴ EX : const

- 기본 클래스를 상속받을 수 없다.
- 순수 가상 함수만 포함 시켜야한다.
- 생성자 / 소멸자/ 연산자를 포함할 수 없다.
- 상속이 전제되기 때문에 public 속성을 가지고 있어야 한다.

-> 장점
- 다중 상속에서의 안정성이 좋다.
ㄴ C++언어에서 많이 발생하는 다중 상속 / 중첩화 현상을 방지할 수 있다.
ㄴ 인터페이스를 이용하면 중첩화 현상 없이 다중 상속을 가능하게 한다.

-> 단점
- 추상화를 기본으로 삼아 구현하기 때문에 가독성이 떨어진다.
- C++ 언어에서는 키워드를 사용할 수 없기 때문에 멤버 변수선언등에 주의를 요해야 한다.
- 강제성이 없고 프로그래머에 의한 실수가 발생한 여지가 아주 다분하다.

* 가상 소멸자 (상속된 소멸자 호출을 위해)
ㄴ 상속 관계에서 사용하면 자식 클래스의 소멸자를 호출한다는 점에서 잠재적인
   오류를 예방하지만 상속 관계가 아닐 경우 성능저하가 발생하기 때문에
   주의해야 한다.

*/
#pragma endregion
/*
HRESULT GameNode::init(void)
{
	// 타이머 초기화
	SetTimer(_hWnd, 1, 10, NULL);

	// 함수가 성공적으로 실행 되었음을 알린다.
	return S_OK;
}

동적할당과 같이 삭제하지 않고 종료하면 메모리 leak
KillTimer(_hWnd, 1);

*/
/*
void GameNode::render(HDC hdc)
{
	자식 객체에서 특징을 렌더한다.
	// ! Do Noting
}
*/